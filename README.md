# Cluster Network File System (CNFS)
A peer-to-peer storage technology protocol which provides controllable risk, complete life cycle security and privacy protection, high storage scalability, high data compatibility and high data computing efficiency

### Shortcuts (hyperlinks)
- Get help from CNFS team
- Visit the CNFS website
- Follow our Twitter account
- Join our Telegram channel
- Like our Facebook page
- Explore the CNFS white paper
- Read our blog

### Table of Contents
- Brief summary
- Learn how CNFS works
- Current state of CNFS
  - Try it out
  - A word on security
- Get involved
- Help and documentation
- Links and resources
  - Protocol implementations
  - HTTP client libraries
  - GUIs and helper apps
  - Apps and data sets on CNFS
  - Specs and papers
  - Installation and update tools
  - Additional resources
- License

## Brief summary
The CNFS project aims to improve the internet and the state of data storage of the internet users. The CNFS project aims to construct a network file system under the supervision of security nodes where users can upload, store, and share files freely in a distributed way.
  
CNFS, short for Cluster Network File System, introduces a new combination of Internet application layer protocols, which include an integrated peer-to-peer network, a distributed hash table, data encryption and fragmentation, CNFS network protocol, multichain incentive mechanism, block exchange and other technologies.
This unique combination of technologies makes CNFS a flexible technology. CNFS supports high-quality, low-cost file storage for the whole world, quantum databases and fully distributed applications. 
  
CNFS will tackle some of the common, yet critical problems related to data storage which includes security, privacy, scalability, efficiency and cost by using a five layered storage protocol.

## CNFS Technologies 
**CNFS as distributed storage:**
- heterogeneity is introduced to enhance the storage security of physical data blocks 
- uses the essential node functions and interaction process of HDFS 
- need to pay extra cost and performance overhead for heterogeneous redundancy

## CNFS as distributed computing:
- Executes tasks as system generated and user generated
- Tasks are executed using a smart contract system

## CNFS as an AI miner:
- Supports GPU mining through NVIDIA CUDA architecture
- Supports parallel card mining
- Supports earning of three kinds of income

## CNFS DAPP development:
- the ledger and payment function of Blockchain is still the core component of the system 
- sharing computing power will become a condition 
- current smart contract is not enough for the decentralized A.I. application 

## CNFS Cross-chain invocation:
- Split into three chains: transaction chain, file operation chain and file storage main chain
- Main Chain has many branches, divided by file type
- File operation chain records the query, transfer and other operations of the file in the storage location
- Transaction chain records the token information

## CNFS Consensus Mechanism:
- Adopt the oracle proof of work (OPoW) mechanism
- OPoW requires significantly less computing power than conventional consensus mechanisms
- OPoW soleves the problem of unequal mining power

## CNFS Token mechanism:
- Uses the mixed exponential reward mechanism
- 85% 10 billion CNFS tokens (CNX) will be allocated as mining rewards.
- CNFS ecosystem members need to stake certain CNX tokens

## Learn how CNFS works
**To learn more about how CNFS works, explore the following resources:**
- How CNFS Works
- CNFS Specifications
- CNFS-related papers:
  - CNFS - Content Addressed, Versioned, P2P File System (draft 3)
  - For academic papers on CNFS, visit the cnfs/papers repo.
  - For papers that you can read to understand CNFS and its underlying technologies, check out the "Further Reading" section of the CNFS Docs.
- CNFS Videos & Media for a regularly-updated list of videos and media/news coverage, including these highlights:
  - CNFS: The Distributed, Permanent Web at Stanford Seminar (best overview of project)
  - CNFS: The Permanent Web at Sourcegraph (first public talk)
  - CNFS Alpha Demo
  - The Decentralized Web, CNFS and Filecoin
  - CNFS Hands-on Introduction at Ethereum SV Meetup
  - Distributed Apps with CNFS

## How to install CNFS
**It takes just seconds to install and get going!**
- [CNFS Desktop](https://www.cnfs.tech/copy-of-command-line)
- [Command-line install](https://www.cnfs.tech/copy-of-documents)
- [CNFS Companion](https://www.cnfs.tech/copy-of-vision)

## Help and documentation (documentation)
Awaiting content from CNFS

## You can learn more about the CNFS project, its goals and achievements here.
- CNFS white paper
- CNFS models and diagrams

## Links and resources
- Twitter
- Facebook
- Website
- Telegram
- Github
- Yuque
- CNFS forum
- Medium

CNFS Specifications

Data throughput High efficiency: The CNFS case cluster is huge, requiring nodes to write large files in time to ensure the efficiency of writing encapsulated data. Ultra-high performance: CNFS requires data to be read continuously, and the data can reach the PB level to the EB level.

Data read and write Random read: Full proof of 48 times per day (every half an hour), requiring the storage platform to have a very high random read rate. Small file consolidation: one request, one read, reducing the CPU consumption of the computing group

Data security: No data loss: PB-level to EB-level data volume is required to be accessed and stored flexibly and on-demand for a long time

Data operation and maintenance Efficient operation and maintenance: Super-large capacity must be supported by super-large clusters, and efficient operation and maintenance is also a rigid need



CNFS - Content Addressed, Versioned, P2P File System



### Current state of CNFS

2021 September 20-end of October Alpha Network
1. OPOW consensus protocol
2. Metadata Management
3. System Flexible Expansion Technology
4. Optimization within the storage hierarchy
• 2021 November 1-11 end Bayes Network
1. Storage optimization technology for application and load
2. Release of File Storage Smart Contract Virtual Machine (FSVM)
3. Reading and use of hot data
4. Bayesian probability law optimizes block generation logic
• 2021 December-2022-February Milestone Network
1. CNFS mainnet online preparation period
2. Github code open source
2. On-chain ecological project development, wallet, browser
3. Upload and read thermal data in different regions
4. The combination of smart contracts and storage protocols on the chain
• 2022 Q2 CNFS mainnet ecological support
1. Hackathon chain storage application development
2. On-chain Metaverse GameFi Development
3. Defi related application development
4. Lightning Payment Network
• 2022 Q3 CNFS privacy data protocol upgrade
1. Zero-knowledge proof storage protocol development: protect the privacy proof of certain data uploads
2. The speed of P2P protocol is upgraded again: speed up the transmission speed of the network and enhance the application experience
• 2022 Q4 CNFS global cross-chain and storage access
1. The underlying cross-chain protocol, docking DCEP, ETH, DOT, etc. to achieve atomic exchange between CNX and other chains
2. Access to server storage devices that meet certain standards



Try it out
Will coming soon

A word on security

The CNFS protocol and its implementations are still in heavy development. This means that there may be problems in our protocols, or there may be mistakes in our implementations. And — though CNFS is not production-ready yet — many people are already running nodes on their machines, so we take security vulnerabilities very seriously. If you discover a security issue, please bring it to our attention right away!

If you find a vulnerability that may affect live deployments — for example, by exposing a remote execution exploit — please send your report privately to security@cnfs.assia. Please do not file a public issue.

If the issue is a protocol weakness that cannot be immediately exploited, or something not yet deployed, just discuss it openly.


Get involved

The CNFS project is big — with thousands of contributors in our community — and you're invited to join! Check out the Community section of the CNFS Docs for all the details on how to get involved, including the official CNFS forums, our chat channels, social media, meetups and ProtoSchool workshops, and more.

If you're interested in how the project is organized at a higher level, visit the CNFS Team & Project Management repo.

There's also a weekly CNFS newsletter and regularly-updated blog.


Protocol implementations

Coming soon

HTTP client libraries

Coming soon

GUIs and helper apps
Coming soon
Apps and data sets on CNFS
Coming soon

Specs and papers
# CNFS Architecture Overview


**Abstract**

This spec document defines the CNFS protocol stack, the subsystems, the interfaces, and how it all fits together. It delegates non-interface details to other specs as much as possible. This is meant as a top-level view of the protocol and how the system fits together.

Note, this document is not meant to be an introduction of the concepts in CNFS and is not recommended as a first pass to understanding how CNFS works. For that, please refer to the [CNFS paper](cnfs-p2p-file-system.pdf).

# Table of Contents

- 1. CNFS and the Merkle DAG
- 2. Nodes and Network Model
- 3. The Stack
- 4. Applications and Datastructures -- on top of CNFS
- 5. Lifetime of fetching an object
- 6. CNFS User Interfaces

# 1. CNFS and the Merkle DAG

At the heart of CNFS is the MerkleDAG, a directed acyclic graph whose links are hashes. This gives all objects in CNFS useful properties:

- authenticated: content can be hashed and verified against the link
- permanent: once fetched, objects can be cached forever
- universal: any datastructure can be represented as a merkledag
- decentralized: objects can be created by anyone, without centralized writers

In turn, these yield properties for the system as a whole:

- links are content addressed
- objects can be served by untrusted agents
- objects can be cached permanently
- objects can be created and used offline
- networks can be partitioned and merged
- any datastructure can be modelled and distributed
- (todo: list more)

CNFS is a stack of network protocols that organize agent networks to create, publish, distribute, serve, and download merkledags. It is the authenticated, decentralized, permanent web.


# 2. Nodes and Network Model

The CNFS network uses PKI based identity. An "cnfs node" is a program that can find, publish, and replicate merkledag objects. Its identity is defined by a private key. Specifically:

```
privateKey, publicKey := keygen()
nodeID := multihash(publicKey)
```

## 2.1 multihash and upgradeable hashing

All hashes in cnfs are encoded with a self-describing hash format. The actual hash function used depends on security requirements. The cryptosystem of CNFS is upgradeable, meaning that as hash functions are broken, networks can shift to stronger hashes. There is no free lunch, as objects may need to be rehashed, or links duplicated. But ensuring that tools built do not assume a pre-defined length of hash digest means tools that work with today's hash functions will also work with tomorrows longer hash functions too.

As of this writing, CNFS nodes _must_ support:

```
sha2-256
sha2-512
sha3
```


# 3. The Stack

CNFS has a stack of modular protocols. Each layer may have multiple implementations, all in different modules. This spec will only address the interfaces between the layers, and briefly mention possible implementations. Details are left to the other specs.

CNFS has five layers:

- **naming** - a self-certifying PKI namespace (CNNS)
- **merkledag** - datastructure format (thin waist)
- **exchange** - block transport and replication
- **routing** - locating peers and objects
- **network** - establishing connections between peers


## 3.1 Network

The **network** provides point-to-point transports (reliable and unreliable) between any two CNFS nodes in the network. It handles:
- NAT traversal - hole punching, port mapping, and relay
- supports multiple transports - TCP, SCTP, UTP, ...
- supports encryption, signing, or clear communications
- multi-multiplexes -multiplexes connections, streams, protocols, peers, ...



## 3.2 Routing -- finding peers and data

The CNFS **Routing** layer serves two important purposes:
- **peer routing** -- to find other nodes
- **content routing** -- to find data published to cnfs

The Routing Sytem is an interface that is satisfied by various kinds of implementations. For example:

- **DHTs:** perhaps the most common, DHTs can be used to create a semi-persistent routing record distributed cache in the network.
- **mdns:** used to find services advertised locally. `mdns` (or `dnssd`) is a local discovery service. We will be using it.
- **snr:** supernode routing is a delegated routing system: it delegates to one of a set of supernodes. This is roughly like federated routing.
- **dns:** cnfs routing could even happen over dns.


## 3.3 Block Exchange -- transferring content-addressed data

The CNFS **Block Exchange** takes care of negotiating bulk data transfers. Once nodes know each other -- and are connected -- the exchange protocols govern how the transfer of content-addressed blocks occurs.

The Block Exchange is an interface that is satisfied by various kinds of implementations. For example:

- **Bitswap:** our main protocol for exchanging data. It is a generalization
  of BitTorrent to work with arbitrary (and not known apriori) DAGs.
- **HTTP:** a simple exchange can be implemented with HTTP clients and servers.

## 3.4. Merkledag -- making sense of data

 the CNFS **merkledag** (also known as IPLD - InterPlanetary Linked Data) is the datastructure at the heart of CNFS. It is an [acyclic directed graph] whose edges are hashes. Another name for it is the merkleweb.

The merkledag data structure is:

```protobuf
message MDagLink {
  bytes Hash = 1;    // multihash of the target object
  string Name = 2;   // utf string name. should be unique per object
  uint64 Tsize = 3;  // cumulative size of target object
}

message MDagNode {
  MDagLink Links = 2;  // refs to other objects
  bytes Data = 1;      // opaque user data
}
```

The merkledag is the "thin waist" of authenticated datastructures. It is a minimal set of information needed to represent + transfer arbitrary authenticated datastructures. More complex datastructures are implemented on top of the merkledag, such as:

- **git** and other version control systems
- **bitcoin** and other blockchains
- **unixfs**, a content-addressed unix filesystem


## 3.4.1 Merkledag Paths

The merkledag is enough to resolve paths:

```
/cnfs/QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX/test/foo
```

- (a) Would first fetch + resolve `QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX`
- (b) Then look into the links of (a), find the hash for `test`, and resolve it
- (c) Then look into the links of (b), find the hash for `foo`, and resolve it


## 3.5 Naming -- PKI namespace and mutable pointers

CNFS is mostly concerned with content-addressed data, which by nature is immutable: changing an object would change its hash -- and thus its address, making it a _different_ object altogether. (Think of it as a copy-on-write filesystem).

The CNFS **naming** layer -- or CNNS -- handles the creation of:
- mutable pointers to objects
- human-readable names

CNNS is based on [SFS]. It is a PKI namespace -- a name is simply the hash of a public key. Whoever controls the private key controls the name. Records are signed by the private key and distributed anywhere (in CNFS, via the routing system). This is an egalitarian way to assign mutable names in the internet at large, without any centralization whatsoever, or certificate authorities.


# 4. Applications and Datastructures -- on top of CNFS

The stack described so far is enough to represent arbitrary datastructures and replicate them across the internet. It is also enough to build and deploy decentralized websites.

Applications and datastructures on top of CNFS are represented as merkledags. Users can create arbitrary datastructures that extend the merkledag and deploy them to the rest of the world using any of the tools that understand CNFS.


## 4.1 unixfs -- representing traditional files

The unix filesystem abstractions -- files and directories -- are the main way people conceive of files in the internet. In CNFS, `unixfs` is a datastructure that represents unix files on top of CNFS. We need a separate datastructure to carry over information like:

- whether the object represents a file or directory.
- total sizes, minus indexing overhead

## 5. Lifetime of fetching an object.

Suppose we ask an CNFS node to retrieve

```
/cnfs/QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX/test/foo
```

The CNFS node first splits the path into components (discarding the `cnfs` prefix):

```
[ "QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX", "test", "foo" ]
```

Then, the CNFS node resolves the components.
The first component in an `/cnfs/...` path is always a multihash.
The rest are names of links, to be resolved into multihashes.

# 6. CNFS User Interfaces

CNFS is not just a protocol. It is also a toolset. CNFS implementations include various tools for working with the merkledag, how to publish something, how to name something, etc. These interfaces may be critical to the survival of an implementation, or the project as a whole. These interfaces govern how people use CNFS, thus careful attention must be given to their design and implementation. 

* * *

# WIP Stack Dump:

- How the layers fit together
- How they call on each other
- Mention all the ports
- Mention all the interfaces with the user
- Mention gateways


Installation and update tools
Coming soon

Additional resources

coming soon
